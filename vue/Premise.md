# Vueの前提知識

## Vueの良さ
- 言語の役割ではなく、機能や関心ごとでコンポーネント化できる。（同じファイルにHTML5を記述できるので）

## Vueの設計について
- プログレッシブフレームワーク（設計思想）
  - 「フレームワークはどんなときでも、どんな規模でも、段階的に柔軟に使えるべきである」
  - 必要になった時に問題解決するライブラリを適宜導入して、問題を解決するという姿勢を持っている。
  - Vue.js自体はViewのみを担当し、+aの機能は必要に応じてライブラリを導入することで実現する。（プログレッシブに機能を追加していく）
  - 他のライブラリや既存のプロジェクトに組み込むことができる
  - 既存のプロジェクトに組み込む場合は、少しずつ導入していくことができる
  - プログレッシブフレームワークの段階
    - 宣言的レンダリング
    - コンポーネントシステム
    - クライアントサイドルーティング
    - 大規模開発向けの状態管理
    - ビルドシステム
    - クライアントサーバデータ永続化
- MVVMモデルに大きく影響を受けている
  - Model: データ
  - View: ユーザーインターフェース
  - ViewModel: データとビューの間の仲介者

## Vueの歴史
1. 2013年にEvan YouがVueを開発
2. 2014年2月にVueの最初のバージョンがリリース(0.8)
3. 2015年4月にLaravelへの標準搭載が決定し、Laravelコミュニティで注目を集める
4. 2015年10月にVue 1.0がリリース
5. 2016年10月にVue 2.0がリリース

## Vue.jsが生まれた理由＝Webフロントエンドの複雑化
- SPAなどでWebフロントエンドに複雑な処理を置くことが増えた<br>※昔は装飾のみがメインだった。
- 複雑化の流れ
    1. Webの誕生：装飾のみ
    2. Ajaxの登場：非同期処理の処理も。jQueryが人気を集める
    3. HTML5の登場とWebのアプリケーションフォーム化
        - DOM APIの仕様変更
        - History APIの登場(ブラウザでなくJSでページ遷移をハンドリングできるようになり、SPAが実現できるように)
    4. Node.jsによるJSエコシステムの進化
        - 今までブラウザに閉じられていた実行環境がより広く使えるようになった
        - npmの普及
    5. ES2015によるプログラミング言語としての進化（大きな言語仕様の変更だった）
        - 代表的な変更点
            - const/letの導入
            - アロー関数の導入
            - テンプレート文字列の導入
            - 分割代入の導入
            - クラス構文の導入
            - モジュール構文の導入
            - Promiseの導入
            - スプレッド構文の導入
        - babelによるトランスパイルの普及（JavaScript to JavaScript）
            - これにより、対応していないブラウザでもES2015の機能を使えるようになった
    6. Reactを始めするフロントエンドライブラリの出現
        - React：仮想DOMを使ったライブラリ
        - Flux：アプリケーションの状態を一元管理するためのアーキテクチャ
        
## フロントエンドの課題とVue
- HTML5以降のアプリケーションプラットフォームとしてのリッチ化と、それに伴うAPIの高速化
- Node.jsエコシステムの発展と開発環境構築の難化
- ES2015以降のシンタックスの教科と、覚えることの多さ
- React以降のフロントエンド開発のフレームワーク化と、フレームワークにまつわる学習コストの高さ

## Vueの特徴
- 学習コストが低い
    - シンプルなAPI
        - UI構築にはHTMLベースの平易なテンプレートを利用する
    - ビルドツールやパッケージ、ES2015などの知識がなくても利用できる

## 基本的な記述方法
```vue
var vm = new Vue({
    el: '#app',
    data: {
        message: 'Hello Vue.js!'
    }
})
```

```html
<div id="app">
    {{ message }}
</div>
```

## データバインディング
- データバインディング：データとビューを同期させる仕組み
- Vueにおいて、DOM要素とJSのデータを結びつけることをデータバインディングと呼ぶ
- Vueではリアクティブなデータバインディングを実現している
    - リアクティブ：データの変更を検知して自動的にDOMに反映する仕組み
    - 一方向のデータバインディング（JSオブジェクト→DOM）
    - 双方向のデータバインディング（JSオブジェクト←→DOM）※👈inputなどでの入力値の変更をJSオブジェクトに反映させることができる

## リアクティブシステム
- オブザーバーパターンをベースに実装されている
- 平たく言えば、状態の変化をVue.jsが検知（監視）して、自動的にDOM側に反映できるようにする仕組み

### リアクティブシステムの仕組み
- 構成要素
    - ウォッチャー（watcher）
        - コンポーネント毎に1つずつ存在
        - render関数の呼び出す
        - リアクティブプロパティの参照する
        - getter：リアクティブプロパティの算出結果を算出してキャッシュする
    - リアクティブプロパティ
        - ウォッチャーに変更を通知
        - setter：リアクティブプロパティの値が変更されたら、ウォッチャーに通知する
        - getter:プロパティに代入された値をgetする
    - render関数
        - DOMに反映する処理を行う
        - ウォッチャーから呼び出される

## レンダリングシステム
- 仮想DOMによる高速レンダリングを提供している
    - DOM操作を簡略化し、高速化するための技術。
    - より高速で、使いやすいDOMを代替で作成し、それを操作し、DOMに反映する
    - 処理の流れ
        1. テンプレートをコンパイルし、AST（抽象構文木）を生成
        1. ASTを最適化
        1. render関数（動的なDOMを生成する関数）とstaticRenderFns（静的なDOMを生成する関数）を生成する
        1. 2で生成した関数を実行し、仮想DOMツリーを生成する。
            - 仮想DOMのdiffとpatch処理によって、DOMの差分を検知し、差分のみを反映する
                - diff：すでにDOM要素としたレンダリングするために利用したDOMツリーと再レンダリングするため生成された仮想DOMツリーから、更新対象となる仮想DOMノードを検出する
                - patch：diffによって算出された更新対象となる仮想DOMノードを、実際のDOMノードに反映する処理。DOMノードの追加、削除、属性の変更などを行う

## Vueのエコシステム
- Vue.jsは単体で利用できるが、エコシステムを利用することで、より高度な開発が可能になる
    - Vue Router：SPAのルーティングを実現する
    - Vuex：アプリケーションの状態管理を実現する
    - Vue Loader：Vue.jsのシングルファイルコンポーネントを実現する(WebPack向けのローダーライブラリ)
    - Vue CLI：Vue.jsの開発を効率化する
    - Vue Devtools：Vue.jsの開発を効率化する
    - Nuxt.js：SPAとSSRに対応したVue.jsのフレームワーク
    - Weex：Vue.jsを利用したネイティブアプリケーションの開発を実現する
    - Onsen UI：モバイル向けのWebアプリケーションを開発するためのUIフレームワーク
    - Awesome Vue：Vue.jsのエコシステムをまとめたリポジトリ
    - Vue Curated：Vue.jsのエコシステムをまとめたリポジトリ（Vue.jsコアチームが厳選したもの）


## JSFiddle
- Vue.jsのコードを実行できるサービス